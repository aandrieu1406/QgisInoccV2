# -*- coding: utf-8 -*-
"""
/***************************************************************************
                                 A QGIS plugin
 InoccDV3F V2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-01-01
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Aurélien Andrieu
        email                : aurelien.andrieu@cerema.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo
from PyQt5.QtGui import QIcon, QPixmap
from qgis.core import QgsProject, QgsApplication, QgsProcessingFeedback, QgsVectorLayer, QgsDataSourceUri, QgsSettings, QgsStyle
from qgis.core import QgsRendererRangeLabelFormat, QgsGraduatedSymbolRenderer, QgsGradientColorRamp, QgsPalLayerSettings, QgsTextFormat
from qgis.core import QgsTextBufferSettings, QgsRuleBasedLabeling, QgsVectorLayerSimpleLabeling, QgsSymbol, QgsSimpleFillSymbolLayer
from qgis.core import QgsRendererCategory, QgsCategorizedSymbolRenderer, QgsFeatureRequest, QgsCoordinateReferenceSystem, QgsVectorLayerExporter
from qgis.core import QgsVectorFileWriter, QgsAction, QgsExpressionContext, QgsPrintLayout, QgsLayoutItemMap
from qgis.utils import iface
from qgis.gui import QgsMapCanvas

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
import os.path
import os,sys,psycopg2
from psycopg2.extensions import AsIs
from datetime import datetime, date
from time import localtime, gmtime, strftime
import csv,shutil
import processing
import webbrowser
from . import doConfirme

#from .classes.Bdd import Bdd

psycopg2.autocommit = True

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qgis_inocc.ui'))


class QGisInoccDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QGisInoccDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)      
        
        # Remplissage des champs des valeurs du serveur Postgres par défaut à partir des information de QGIS.ini
        mDic_Init = self.returnParamServPG()
        self.mDic_Init = mDic_Init
        
        self.lineAdrServ.setText(mDic_Init["AdrServPG"])
        self.linePortServ.setText(mDic_Init["port"])
        self.lineUserServ.setText(mDic_Init["user"]) 
        self.lineMdpServ.setText(mDic_Init["mdp"])
        self.lineBaseDonnees.setText(mDic_Init["NomBD"])               
        self.lineSchema.setText(mDic_Init["schema"])
        self.lineDossierSortie.setText(mDic_Init["dossierSortie"])
        
        self.boutonVoirDossierSortie.clicked.connect(self.SelectionDossierSortie)        
        
        # Bouton de vérification des paramètres du serveur Postgres
        self.boutonParamServPG.clicked.connect(self.CheckConnPG)        

        # Bouton de nettoyage de la base Postgres (suppression des tables du schéma public)
        self.boutonNettoyBase.clicked.connect(self.NettoyerBase)

        # Ouverture fichier de notice DV3F
        self.boutonAfficheNoticeDV3F.clicked.connect(self.AfficheNoticeDV3F)
        
        # Affichage boîte de dialogue initiale
        self.boutonAfficheBoiteDialogue.clicked.connect(self.AfficheBoiteDialogue)
        
        # Lien vers site WEB CEREMA
        self.boutonCerema.clicked.connect(self.LienWebCerema)
        
        # Lien box pour télécharger la couche des communes
        self.boutonDownloadShapeCom.clicked.connect(self.LienCoucheCom)
        
        #Préparation des données initiales (import des couches iris, commune, EPCI, Dept et Reg
        self.boutonPreparationData.clicked.connect(self.PreparationData)

        # Alimentation de la combobox "Région"
        self.alimReg1()
        self.alimReg2()
        self.boutonVoirComReg.clicked.connect(self.AfficheComBoxReg)

        # Contrôle des données d'entrée de la partie zonage personnalisé
        self.boutonControlePerso.clicked.connect(self.ControlePerso)
        
        # Alimentation de la combobox "couches QGIS chargées"
        #self.alimCouchesProjet()
        self.boutonImportFicZonagePerso.clicked.connect(self.alimChampsPerso)        
        #self.comboBoxChoixZonagePerso.currentIndexChanged.connect(self.chargeCouchePerso)

        # Alimentation de la combobox "Communes" depuis département
        self.comboBoxChoixReg.currentIndexChanged.connect(self.alimDep)
        self.comboBoxChoixReg2.currentIndexChanged.connect(self.alimDep2)
        self.boutonVoirComDep.clicked.connect(self.AfficheComBoxDep)    

        # Alimentation de la combobox "Communes" depuis EPCI
        self.comboBoxChoixDep.currentIndexChanged.connect(self.alimEPCI)
        self.boutonVoirComEPCI.clicked.connect(self.AfficheComBoxEPCI)     
        
        ## CheckBox tout sélectionner ou tout délectionner
        self.checkBoxSelectAll.clicked.connect(self.selectAll)
        
        # Bouton ajout communes
        self.boutonAjoutCom.clicked.connect(self.AjoutCommunes)
        
        # Bouton suppression communes
        self.boutonSupprCom.clicked.connect(self.SuppCommunes)
        
        # Bouton Vider la sélection
        self.boutonViderSelec.clicked.connect(self.viderSelection)
        #self.boutonVoirFicDV3FDept.clicked.connect(self.SelectionFicDV3FDept)
        self.boutonImportDV3FDept.clicked.connect(self.ImportDV3FDept)
        #self.boutonVoirFicDV3FInit.clicked.connect(self.SelectionFicDV3FInit)
        self.boutonImportDV3FInit.clicked.connect(self.ImportDV3FInit)
        #self.boutonVoirFicCommune.clicked.connect(self.SelectionFicCommune)
        self.boutonImportFicCommune.clicked.connect(self.ImportCommune)
        
        self.boutonLanceTraitement.clicked.connect(self.verifDV3F1)
        self.boutonLanceTraitement2.clicked.connect(self.execTraitement2)

        #barre de progression
        self.progressBar.hide()
        self.progressBar_2.hide()
        self.progressBar_3.hide()
        
        #changement fond partie initialisation
        self.lineFirstInstall.setStyleSheet("background: #fce3d9")        
        
        #désactivation du bouton de lancement de traitement zonage personnalisé
        self.boutonLanceTraitement2.setEnabled(False)        

    #Lien vers site WEB CEREMA
    def LienWebCerema(self):        
        webbrowser.open("https://www.cerema.fr/fr")

    def LienCoucheCom(self):
        webbrowser.open("https://cerema.box.com/s/1hpo7j059kp0s13bxss3ii3jmr1kni40")
       
    #depuis la fenêtre COM-IRIS
    def alimReg1(self):
        self.alimReg("com_iris")

    #depuis la fenêtre zonage à façon
    def alimReg2(self):
        self.alimReg("perso")
        
    # Remplissage de la combobox choix Région
    def alimReg(self,type):
        listeReg = os.path.dirname(__file__)+"/data/liste_reg.csv"                 
        
        listchoixReg = []
        
        with open (r""+ listeReg +"", newline='') as f:
            readerDep = csv.reader(f, delimiter=';')
            for row in readerDep:
                listchoixReg.append(row[0])
                # Ajout d'items depuis la liste
                # Aucune valeur par défaut
                if type=="com_iris":
                    self.comboBoxChoixReg.clear()
                    self.comboBoxChoixReg.addItems(listchoixReg)
                    self.comboBoxChoixReg.setCurrentIndex(0)
                else:
                    self.comboBoxChoixReg2.clear()
                    self.comboBoxChoixReg2.addItems(listchoixReg)
                    self.comboBoxChoixReg2.setCurrentIndex(0)                

    def PreparationData(self):
    
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()
        
        schema=self.lineSchema.text()
        
        #Import des couches SIG de base

        self.progressBar_3.show()
        #Chargement des couches EPCI et Département        
        deptEPCI=os.path.dirname(__file__)+"/data/dept_epci.gpkg"
        
        #effacement des tables département et EPCI au préalable
        sqlstr1 = "DROP TABLE IF EXISTS "+schema+".departement;"
        cur.execute(sqlstr1)
        conn.commit()
        sqlstr2 = "DROP TABLE IF EXISTS "+schema+".epci;"
        cur.execute(sqlstr2)
        conn.commit()
        
        for layer in ('departement','epci'):
            gpkg_layer = deptEPCI + "|layername="+layer
            vlayer = QgsVectorLayer(gpkg_layer, layer, "ogr")
            con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=my_id schema="+schema+" table="+layer
            err = QgsVectorLayerExporter.exportLayer(vlayer, con_string, 'postgres', QgsCoordinateReferenceSystem(2154), False)

        val_progression=20        
        self.progressBar_3.setValue(val_progression)            
             
        
        #Import des fonctions de calcul d'indicateurs dans la base
        dossier_fonction=os.path.dirname(__file__)+"/data/fonctions_sql/"        
        indic=["evolution","global","foncier","maison","appartement"]
        for i in indic:
            # Read in the file
            with open(dossier_fonction+"fonction_ind_"+i+"_init.sql", 'r') as file :
                filedata = file.read()
            filedata = filedata.replace('public.', schema+'.')
            with open(dossier_fonction+"fonction_ind_"+i+".sql", 'w') as file:
                file.write(filedata)
            self.execFicSql(fichier=dossier_fonction+"fonction_ind_"+i+".sql",param='')    
            
        QMessageBox.information(self,"Information","Les entités administratives et les fonctions de calcul des indicateurs ont été correctement chargés.")
        conn.close()
        self.progressBar_3.hide()
        
    def AfficheComBoxReg(self):
        self.TestDonneesDV3F('reg')
    
    def alimDep(self):
        self.alimDept("orig1")

    def alimDep2(self):
        self.alimDept("orig2")
        
    # Remplissage de la combobox choix Département
    def alimDept(self,origine):
        try:
            # Récupération des paramètres de connexion au serveur PG
            conn = self.ConnectServer()        
            cur = conn.cursor()
            
            schema=self.lineSchema.text()

            if origine=="orig1":
                sqlstr1 = "SELECT insee_dep || ' - ' || nom FROM "+schema+".departement WHERE insee_reg = '"+ self.comboBoxChoixReg.currentText().split(" - ")[0] +"' order by insee_dep"
                cur.execute(sqlstr1)
                listchoixdep = cur.fetchall()     
                self.comboBoxChoixEPCI.clear() # Aucune valeur EPCI par défaut                                        
                self.comboBoxChoixDep.clear() # Aucune valeur dep par défaut
                for i in listchoixdep:
                    self.comboBoxChoixDep.addItems(i)
                    self.comboBoxChoixDep.setCurrentIndex(0)
            else:
                sqlstr1 = "SELECT insee_dep || ' - ' || nom FROM "+schema+".departement WHERE insee_reg = '"+ self.comboBoxChoixReg2.currentText().split(" - ")[0] +"' order by insee_dep"
                cur.execute(sqlstr1)
                listchoixdep = cur.fetchall()            
                self.comboBoxChoixDep2.clear()
                for i in listchoixdep:        
                    self.comboBoxChoixDep2.addItems(i)
                    self.comboBoxChoixDep2.setCurrentIndex(0)
        except:
            pass

    def AfficheComBoxDep(self):
        self.TestDonneesDV3F('dep')        

    # Remplissage de la combobox choix EPCI
    def alimEPCI(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()
        
        schema=self.lineSchema.text()
        listeEPCI = os.path.dirname(__file__)+"/data/epci.csv"
        sqlstr1 = "SELECT code_siren || ' - ' || nom FROM "+schema+".epci WHERE insee_dep like '%"+ self.comboBoxChoixDep.currentText().split(" - ")[0] +"%' order by insee_dep"
        cur.execute(sqlstr1)
        listeEPCI = cur.fetchall()
        # Aucune valeur par défaut 
        self.comboBoxChoixEPCI.clear()        
        for i in listeEPCI:
            # Ajout d'items depuis la liste
            self.comboBoxChoixEPCI.addItems(i)
            self.comboBoxChoixEPCI.setCurrentIndex(0)    

    def AfficheComBoxEPCI(self):
        self.TestDonneesDV3F('EPCI')
    
    #Vérification de la présence des données DV3F sur le territoire choisi
    def TestDonneesDV3F(self,type1):
        try:
            # Récupération des paramètres de connexion au serveur PG
            conn = self.ConnectServer()        
            cur = conn.cursor()
            
            schema=self.lineSchema.text()
            
            liste_dep=[]

            if type1=='reg': #cas région                
                reqsql = "SELECT insee_dep from "+schema+".departement WHERE insee_reg='"+ self.comboBoxChoixReg.currentText().split(" - ")[0] +"'"
                cur.execute(reqsql)
                ldep = cur.fetchall()
                if len(ldep)==0:
                    QMessageBox.warning(self,"Attention","Veuillez sélectionner une région !!!")
                else:
                    mess_erreur1 = "Attention !!! Aucune donnée DV3F sur le(s) département(s) suivant(s) :\n"
                    mess_erreur2 = ""
                    for i in ldep:
                        #print(i[0])
                        reqsql = "SELECT coddep from dvf.mutation WHERE coddep IN ('"+i[0]+"') limit 1"
                        cur.execute(reqsql)
                        ldep2 = cur.fetchall()
                        if len(ldep2)==0:
                            mess_erreur2+=" - "+i[0]+"\n"                    
             
                    if mess_erreur2!="":
                        mess_erreur=mess_erreur1+mess_erreur2+"Le résultat du traitement sera tronqué sur les communes de(s) département(s) listé(s) ci-dessus !!!"
                        QMessageBox.warning(self,"Attention",mess_erreur)

                    else :
                        pass
                        
                    self.ListeCommunes.clear()
                    self.ListeCommunesSelec.clear()
                    self.lineNbComSelec.clear()                    
                    self.AfficheAnnees('reg')
                #print (liste_dep)
            elif type1=='dep': #cas département
                numdep=self.comboBoxChoixDep.currentText().split(" - ")[0]
                reqsql="SELECT coddep from dvf.mutation WHERE coddep IN ('"+ numdep +"') limit 1"
                cur.execute(reqsql)
                ldep=cur.fetchall()
                if len(ldep)==0:
                    mess_erreur = "Attention !!! Aucune donnée DV3F sur le département suivant : \n - " + numdep + "\n"
                    mess_erreur+="Le résultat du traitement sera tronqué sur les communes de ce département !!!"
                    QMessageBox.information(self,"Information",mess_erreur)
                else:
                    pass
                    
                self.ListeCommunes.clear()
                self.ListeCommunesSelec.clear()
                self.lineNbComSelec.clear()                    
                self.AfficheAnnees('dep')
                
            elif type1=='EPCI': #cas EPCI
                reqsql="SELECT insee_dep from "+schema+".epci WHERE code_siren='"+ self.comboBoxChoixEPCI.currentText().split(" - ")[0] +"'"
                #QMessageBox.warning(self,"Attention",reqsql)
                cur.execute(reqsql)
                ldep3=cur.fetchall()
                ldep4=ldep3[0][0].split(",")

                mess_erreur1 = "Attention !!! Aucune donnée DV3F sur le(s) département(s) suivant(s) :\n"
                mess_erreur2 = ""

                for i in ldep4:
                    reqsql = "SELECT coddep from dvf.mutation WHERE coddep IN ('"+str(i)+"') limit 1"
                    cur.execute(reqsql)
                    res=cur.fetchall()
                    if len(res)==0:
                        mess_erreur2+=" - "+str(i)+"\n"
                if mess_erreur2!="":
                    mess_erreur=mess_erreur1+mess_erreur2+"Le résultat du traitement sera tronqué sur les communes du(es) département(s) listé(s) ci-dessus !!!"
                    QMessageBox.warning(self,"Attention",mess_erreur)                
                    
                else :
                    pass
                    
                self.ListeCommunes.clear()
                self.ListeCommunesSelec.clear()
                self.lineNbComSelec.clear()                    
                self.AfficheAnnees('EPCI')
                
        except:
            QMessageBox.warning(self,"Attention","Aucune base DV3F n'est installée sur le serveur. Allez à l'onglet paramètres pour l'importer.")
            pass
        
    #Récupération des années Min et Max depuis la table mutation 
    def AfficheAnnees(self,type1): #type1 = reg, dep, EPCI ou perso
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()

        req="SELECT anneemut from dvf.mutation group by anneemut order by anneemut limit 1"
        cur.execute(req)
        result=cur.fetchall()
        anneeMin=result[0][0]
        #QMessageBox.warning(self,"Attention",str(anneeMin))
        req="SELECT anneemut from dvf.mutation group by anneemut order by anneemut DESC limit 1"
        cur.execute(req)
        result=cur.fetchall()
        anneeMax=result[0][0]
        
        conn.close()
        
        if type1!="perso":            
            self.spinBoxAnneeMin.setRange(int(anneeMin), int(anneeMax))
            self.spinBoxAnneeMin.setSingleStep(1)
            self.spinBoxAnneeMax.setRange(int(anneeMin), int(anneeMax))
            self.spinBoxAnneeMax.setSingleStep(1)
            self.spinBoxAnneeMax.setValue(int(anneeMax))
            self.AfficheComBox(type1)            
        else:
            self.spinBoxAnneeMin2.setRange(int(anneeMin), int(anneeMax))
            self.spinBoxAnneeMin2.setSingleStep(1)
            self.spinBoxAnneeMax2.setRange(int(anneeMin), int(anneeMax))
            self.spinBoxAnneeMax2.setSingleStep(1)
            self.spinBoxAnneeMax2.setValue(int(anneeMax))

    #fonction qui affiche les communes en fonction de l'entité administrative (reg, dep, EPCI)
    def AfficheComBox(self,type1): #type1 = reg, dep ou EPCI
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()   
        
        schema=self.lineSchema.text()
        
        try:

            if type1=='reg':
                reg=self.comboBoxChoixReg.currentText().split(" - ")[0]
                sql = "SELECT insee_com,nom FROM "+schema+".commune WHERE insee_reg='"+reg+"' order by insee_com"
            elif type1=='dep':
                dep=self.comboBoxChoixDep.currentText().split(" - ")[0]
                sql = "SELECT insee_com,nom FROM "+schema+".commune WHERE insee_dep='"+dep+"' order by insee_com"
            else:
                epci=self.comboBoxChoixEPCI.currentText().split(" - ")[0]
                sql = "SELECT insee_com,nom FROM "+schema+".commune WHERE siren_epci like '%"+epci+"%' order by insee_com" 

            cur.execute(sql)
            listeCom = cur.fetchall()
            listeCom2 = []
            #QMessageBox.warning(self,"Attention",str(listeCom[0]))

            for i in listeCom:
                listeCom2.append(i[0] + "  " +i[1])
            self.ListeCommunes.clear()
            self.ListeCommunesSelec.clear()
            self.lineNbComSelec.clear()
            self.ListeCommunes.addItems(listeCom2)
            self.lineNbCom.setText(str(len(listeCom2)))
            self.checkBoxSelectAll.setChecked(False)
            
            conn.close()
        except:
            QMessageBox.warning(self,"Attention","La date de fin doit être plus grande !!!")
            pass

    # Fonction qui ajoute les communes sélectionnées pour lancer le traitement            
    def AjoutCommunes(self):
        nbSelecListeCom_2 = self.ListeCommunesSelec.count()

        if nbSelecListeCom_2 > 0 :

            itemsListeCom = []
            for index in range(self.ListeCommunesSelec.count()):
                itemsListeCom.append(self.ListeCommunesSelec.item(index))
            labelsListeCom_2 = [i.text() for i in itemsListeCom]

            itemsCommunes=[]
            for value in self.ListeCommunes.selectedItems():
                if str(value.text()) not in labelsListeCom_2:
                    itemsCommunes.insert(-1,str(value.text()))
                else:
                    pass

            self.ListeCommunesSelec.addItems(itemsCommunes)

        else :
            itemsCommunes=[]
            for value in self.ListeCommunes.selectedItems():
                itemsCommunes.insert(0,str(value.text()))
            self.ListeCommunesSelec.addItems(itemsCommunes)
            
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))

    #vérification des données pour les zonages Communes et IRIS
    def verifDV3F1(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()
        
        ldep = os.path.dirname(__file__)+"/data/ldep.csv"

        an1=self.spinBoxAnneeMin.value()
        an2=self.spinBoxAnneeMax.value()
                
        if an2<an1:
            QMessageBox.critical(self,"Erreur","La date de fin doit être plus grande !!!")
        else:    
            if self.ListeCommunesSelec.count()==0:
                QMessageBox.critical(self,"Erreur","Veuillez sélectionner au moins une commune !!!")
            else:
                reply = QMessageBox.question(self, 'Confirmation','Le traitement efface le projet QGIS en cours. Voulez-vous continuer ?', QMessageBox.Yes, QMessageBox.No)
                if reply == QMessageBox.Yes:

                    items = []
                    for index in range(self.ListeCommunesSelec.count()):
                        items.append(self.ListeCommunesSelec.item(index))
                    com = [i.text() for i in items]
                    liste_idcom1 = []
                    for element in com:
                        liste_idcom1.append(element[:5])
                        
                    liste_idcom2="('"
                    for item in liste_idcom1:
                        #print(item)
                        liste_idcom2=liste_idcom2+item+"','"
                    liste_idcom2=liste_idcom2[:-2]

                    if self.checkBoxFusionCom.isChecked()==1:
                        texte_groupe='groupe'
                    else:
                        texte_groupe='non_groupe'
                        
                    id_zone = ""
                    for item2 in liste_idcom1:
                        id_zone = id_zone+item2+","
                    id_zone = id_zone[:-1]
                    
                    liste_com=liste_idcom2+");"+id_zone+";"+texte_groupe+";"+str(an1)+";"+str(an2)
                    fichier = open(os.path.dirname(__file__)+"/data/liste_com.txt", "w")
                    fichier.write(liste_com)
                    fichier.close()
                    
                    #execution des scripts une fois les communes sélectionnées
                    self.execTraitement1("com",str(an1),str(an2))
                else:
                    pass

    #Mise au format des tables avant lancement des scripts pour le niveau commune
    def execTraitement1(self,type,an1,an2):
        global table_log,sql_logfile
            
        #init log
        try:
            os.mkdir(os.path.dirname(__file__)+'/log')
        except:
            pass
        try:
            self.initLog(os.path.dirname(__file__)+'/log')
        except:
            pass
            
        #Execution des scripts SQL des indicateurs pour la maille commune
        
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()
        
        schema=self.lineSchema.text()        
        #récupération variable pour le zonage
            
        with open(os.path.dirname(__file__)+"/data/liste_com.txt", "r") as csvfile:
            spamreader = csv.reader(csvfile, delimiter=';')
            for row in spamreader:
                liste_com=row[0]
                nom_zone=row[1]
                test_groupe=row[2]
                annee1=row[3]
                annee2=row[4]
        
        # création couche zonage
        cur.execute('DROP TABLE IF EXISTS '+schema+'.zonage cascade;')
        conn.commit()
        if test_groupe=='groupe':
            cur.execute('CREATE TABLE '+schema+'.zonage as SELECT row_number() over() as id,\'fusion des communes '+nom_zone+'\'::text as nom,\''+annee1+' - '+annee2+'\'::varchar(15) as periode,St_Union(geom) as geom FROM '+schema+'.commune WHERE insee_com IN '+liste_com+';')
            conn.commit()
        else:
            cur.execute('CREATE TABLE '+schema+'.zonage as SELECT insee_com as id, nom,\''+annee1+' - '+annee2+'\'::varchar(15) as periode, geom::geometry(MultiPolygon,2154) FROM '+schema+'.commune WHERE insee_com IN '+liste_com+';')
            conn.commit()
        
        #création index spatial
        cur.execute("ALTER TABLE "+schema+".zonage ADD CONSTRAINT zonage_pkey PRIMARY KEY (id);")
        conn.commit()
        cur.execute("CREATE INDEX zonage_geomidx ON "+schema+".zonage USING gist(geom) TABLESPACE pg_default;")
        conn.commit()
        self.execScripts(an1,an2,'com_iris')


    # Fonction supprimer des communes
    def SuppCommunes(self):
        for value in self.ListeCommunesSelec.selectedItems():
            self.ListeCommunesSelec.takeItem(self.ListeCommunesSelec.row(value))
        
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))

    # Fonction Vider la sélection
    def viderSelection(self):
        self.ListeCommunesSelec.clear()
        self.lineNbComSelec.setText(str(self.ListeCommunesSelec.count()))
        
    def selectAll(self):
        if self.checkBoxSelectAll.isChecked()==1 :
            self.ListeCommunes.selectAll()
        else :
            self.ListeCommunes.clearSelection()
    

    # *********************************************
    # ******* Section zonage personnalisé *********
    # *********************************************

    def alimChampsPerso(self):        
        try:
            filenamePerso = self.recupCheminFichierShp()
            field_names=[]
            #self.lineFicZonPerso.text()
            QgsProject.instance().clear()
            QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(2154))
            vlayer = iface.addVectorLayer(filenamePerso, os.path.splitext(os.path.basename(filenamePerso))[0], "ogr")
            self.lineNomCouchePerso.setText(os.path.splitext(os.path.basename(filenamePerso))[0])
            if not vlayer or not vlayer.isValid():
                QMessageBox.information(self,"Information","Erreur de chargement de la couche!")
                pass
            else:
                for field in vlayer.fields():
                    #print(field.name(), field.typeName())
                    field_names.append(field.name())
                    self.comboBoxChoixChampId.clear()
                    self.comboBoxChoixChampId.addItems(field_names)
                    self.comboBoxChoixChampId.setCurrentIndex(0)
                    self.comboBoxChoixChampNom.clear()
                    self.comboBoxChoixChampNom.addItems(field_names)
                    self.comboBoxChoixChampNom.setCurrentIndex(0)                    
            
                #self.alimCouchesProjet()
        except:
            QgsProject.instance().clear()
            self.lineNomCouchePerso.setText("")
            self.comboBoxChoixChampId.clear()
            self.comboBoxChoixChampNom.clear()
            pass

    def ControlePerso(self):
        #Création du fichier liste_com.txt, servant pour les requêtes SQL
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()        
        cur = conn.cursor()

        schema=self.lineSchema.text()        
    
        #Contrôle de la présence de données DV3F sur le département choisi
        numdep2=self.comboBoxChoixDep2.currentText().split(" - ")[0]
        if numdep2 =="":
            QMessageBox.warning(self,"Attention","Aucun département sélectionné !!!")
        else:
            try:            
                #QMessageBox.information(self,"Information","SELECT coddep from dvf.mutation WHERE coddep IN ('"+ numdep2 +"') limit 1")
                sql="SELECT coddep from dvf.mutation WHERE coddep IN ('"+ numdep2 +"') limit 1"
                cur.execute(sql)
                ldep=cur.fetchall()
                
                #QMessageBox.information(self,"Information",numdep2)
                if len(ldep)==0:
                    mess_erreur = "Aucune donnée DV3F sur le département sélectionné.\nLe résultat du traitement risque d'être tronqué !!!"
                    QMessageBox.warning(self,"Information",mess_erreur)
                    pass
                else:
                    # Import de la couche personnalisée dans la base et modification des champs      
                    layer = QgsProject.instance().mapLayersByName(self.lineNomCouchePerso.text())[0]
                    idFieldName = self.comboBoxChoixChampId.currentText()
                    NomFieldName = self.comboBoxChoixChampNom.currentText()
                    #print( idFieldName +"  " +NomFieldName )
                    
                    if idFieldName==NomFieldName:
                        QMessageBox.critical(self,"Erreur","Les champs [id] et [nom] doivent être différents !!!")
                    else:
                        #QMessageBox.warning(self,"Attention",str(layer.wkbType()))
                        #print( str(layer.wkbType()) )
                        if layer.wkbType() == 6: #type polygon
                            cur.execute("DROP TABLE IF EXISTS "+schema+".zonage_perso2;")
                            conn.commit()
                            #récupération des informations de connexion à la base
                            AdrServPG=self.lineAdrServ.text()
                            port=self.linePortServ.text()
                            user=self.lineUserServ.text()
                            mdp=self.lineMdpServ.text()
                            NomBD=self.lineBaseDonnees.text()      
                            con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=id type=MULTIPOLYGON schema="+schema+" table=zonage_perso2 (geom)"
                            err = QgsVectorLayerExporter.exportLayer(layer, con_string, 'postgres', QgsProject.instance().crs(), False)                        
                            
                            # Copie de zonage_perso2 vers zonage_perso avec changement de nom de colonne id et nom (et consevation du champ geom)
                            cur.execute("DROP TABLE IF EXISTS "+schema+".zonage_perso;")
                            conn.commit()
                            #print("ici")
                            cur.execute('CREATE TABLE '+schema+'.zonage_perso AS SELECT '+idFieldName.lower()+' AS id, '+NomFieldName.lower()+' AS nom, geom FROM '+schema+'.zonage_perso2;')
                            #print("là")
                            cur.execute("ALTER TABLE "+schema+".zonage_perso ADD CONSTRAINT zonage_perso_pkey PRIMARY KEY (id);")
                            cur.execute("CREATE INDEX ON "+schema+".zonage_perso using GIST(geom);")
                            conn.commit()                   

                        else:
                            QMessageBox.warning(self,"Attention","La couche sélectionnée n'est pas conforme. Veuillez sélectionner une couche de polygones !!!")
                            
                        self.AfficheAnnees('perso')
                        self.boutonLanceTraitement2.setEnabled(True)
                        QMessageBox.information(self,"Information","Le contrôle a été réalisé avec succès. Vous pouvez lancer le traitement.")
            
            except:
                QMessageBox.critical(self,"Erreur","Problème dans l'import. Vérifiez que la couche personnalisée est conforme (présence d'un champ ID unique, couche de type polygone)!!!")
                pass

                
    #Mise au format des tables avant lancement des scripts pour le zonage à façon
    def execTraitement2(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()
        
        schema=self.lineSchema.text()
        
        an1=self.spinBoxAnneeMin2.text()
        an2=self.spinBoxAnneeMax2.text()

        reply = QMessageBox.question(self, "Confirmation","Le traitement efface le projet QGIS en cours. Voulez-vous continuer ?", QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes:        
            try:
                cur.execute('DROP TABLE IF EXISTS '+schema+'.zonage cascade;')
                conn.commit()
                #formatage du zonage perso
                cur.execute('CREATE TABLE '+schema+'.zonage as SELECT id, nom,\''+an1+' - '+an2+'\'::varchar(15) as periode, geom FROM '+schema+'.zonage_perso;')
                conn.commit()
                
                #création index spatial
                cur.execute("ALTER TABLE "+schema+".zonage ADD CONSTRAINT zonage_pkey PRIMARY KEY (id);")
                conn.commit()
                cur.execute("CREATE INDEX ON "+schema+".zonage USING gist(geom) TABLESPACE pg_default;")
                conn.commit()
                conn.close()
                self.execScripts(an1,an2,'perso')
            except:
                QMessageBox.critical(self,"Erreur","Aucune couche de zonage personnalisé n'est présente dans la base !!!")
                pass
        else:
            pass
                            
                
    #Lancement des scripts pour les indicateurs
    def execScripts(self,an1,an2,type):
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()
        
        #Création dossier sortie dv3f
        dossierSortie=self.lineDossierSortie.text()
        if not os.path.exists(self.lineDossierSortie.text()):
            try:
                os.mkdir(self.lineDossierSortie.text())            
            except:
                QMessageBox.warning(self,"Attention","Le dossier de sortie n'a pas été créé !!! Faites-le manuellement.")
                pass
        else:
            pass
            
        schema=self.lineSchema.text()                
        
        #création du schéma de stockage des résultats
        libDate = datetime.now().strftime("%Y%m%d_%Hh%Mm%Ss")
        chemin=dossierSortie+os.sep+"result_"+libDate
        #Execution des scripts des indicateurs
        val_progression=0
        if type=="perso":
            self.progressBar.hide()
            self.progressBar_2.show()
            self.progressBar_2.setValue(val_progression)
        else:
            self.progressBar_2.hide()
            self.progressBar.show()
            self.progressBar.setValue(val_progression)            

        cur.execute("SELECT "+schema+".__ind_evolution('"+str(an1)+"','"+str(an2)+"','"+libDate+"');")
        val_progression=10        
        self.progressBar.setValue(val_progression)
        self.progressBar_2.setValue(val_progression)

        cur.execute("SELECT "+schema+".__ind_global('"+str(an1)+"','"+str(an2)+"','"+libDate+"');")
        val_progression=50
        self.progressBar.setValue(val_progression)
        self.progressBar_2.setValue(val_progression)

        cur.execute("SELECT "+schema+".__ind_appartement('"+str(an1)+"','"+str(an2)+"','"+libDate+"');")
        val_progression=70
        self.progressBar.setValue(val_progression)
        self.progressBar_2.setValue(val_progression)

        cur.execute("SELECT "+schema+".__ind_maison('"+str(an1)+"','"+str(an2)+"','"+libDate+"');")
        val_progression=85
        self.progressBar.setValue(val_progression)
        self.progressBar_2.setValue(val_progression)

        cur.execute("SELECT "+schema+".__ind_foncier('"+str(an1)+"','"+str(an2)+"','"+libDate+"');")
        conn.commit()

        
        try:
            os.mkdir(chemin)
        except:
            pass

        QgsProject.instance().clear()
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(2154))
        root = QgsProject.instance().layerTreeRoot()
        root.addGroup("indicateurs DV3F")
        parent = root.findGroup("indicateurs DV3F")
        
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()        
        
        uriPG = QgsDataSourceUri()
        uriPG.setConnection(AdrServPG,port,NomBD,user,mdp)
        
        GpName =chemin+"/indicateurs.gpkg"
        for ind in ('foncier','appartement','maison','global','evolution'):

            if ind=='evolution':
                uriPG.setDataSource(schema,"ind_"+ind+"_"+libDate,None)             
            else:
                uriPG.setDataSource(schema,"ind_"+ind+"_"+libDate,"geom")

            layer_indic=QgsVectorLayer(uriPG.uri(),"ind_"+ind,"postgres")
            
            #Sauvegarde des indicateurs au format gpkg
            context = QgsProject.instance().transformContext()
            options = QgsVectorFileWriter.SaveVectorOptions()
            if os.path.isfile(GpName):
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.layerName = layer_indic.name()
            options.fileEncoding = layer_indic.dataProvider().encoding()
            options.driverName = "GPKG"
            QgsVectorFileWriter.writeAsVectorFormatV2(layer_indic, GpName, context, options)

            QgsProject.instance().addMapLayer(layer_indic, False)            
            parent.addLayer(layer_indic)
            
        QgsProject.instance().clear()
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(2154))
        canvas = QgsMapCanvas()
        canvas.show()
        #Chargement des couches GPKG        
        GpName2=chemin+"/indicateurs.gpkg"
        for ind in ('foncier','appartement','maison','global','evolution'):
            gpkg_layer = GpName2 + "|layername=ind_"+ind
            vlayer = QgsVectorLayer(gpkg_layer, ind, "ogr")
            QgsProject.instance().addMapLayer(vlayer)

            #Travail sur la symbologie : affichage selon la méthode de Jenks sur la variable globale "nombre de transactions"              
            if ind=='global':
                champs = 'nb_vente'
                for feat in vlayer.getFeatures():
                    symbol = QgsSymbol.defaultSymbol(vlayer.geometryType())
                    defaultColorRampNames = QgsStyle().defaultStyle().colorRampNames()
                    mode = QgsGraduatedSymbolRenderer.Jenks
                    colorRamp = QgsStyle().defaultStyle().colorRamp(defaultColorRampNames[6])  #2=vert, 3=violet, 4=jaune-bleu, 5=bleu, 6=vert, 7=gris,                     
                    renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, champs, 4, mode, symbol, colorRamp )                  
                    vlayer.setRenderer(renderer)
                    vlayer.setName(ind+" - "+champs)
                    
                    #ajout d'étiquette sur le nom
                    layer_settings  = QgsPalLayerSettings()
                    text_format = QgsTextFormat()
                    text_format.setFont(QFont("Verdana", 10))
                    text_format.setSize(10)
                    buffer_settings = QgsTextBufferSettings()
                    buffer_settings.setEnabled(True)
                    buffer_settings.setSize(1)
                    buffer_settings.setColor(QColor("white"))
                    text_format.setBuffer(buffer_settings)
                    layer_settings.setFormat(text_format)
                    layer_settings.fieldName = "nom"
                    layer_settings.enabled = True
                    layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
                    vlayer.setLabelsEnabled(True)
                    vlayer.setLabeling(layer_settings)
                    vlayer.triggerRepaint()
                                        
            #cette partie ralentit le taritement -> commentée
            '''
            elif ind=='maison':
                champs = 'nb_maison'
                for feat in vlayer.getFeatures():
                    symbol = QgsSymbol.defaultSymbol(vlayer.geometryType())
                    defaultColorRampNames = QgsStyle().defaultStyle().colorRampNames()
                    mode = QgsGraduatedSymbolRenderer.Jenks
                    colorRamp = QgsStyle().defaultStyle().colorRamp(defaultColorRampNames[3])  #2=vert, 3=violet, 4=jaune-bleu, 5=bleu, 6=vert, 7=gris,                     
                    renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, champs, 4, mode, symbol, colorRamp )                  
                    vlayer.setRenderer(renderer)
                    vlayer.setName(ind+" - "+champs)
                    
            elif ind=='appartement':
                champs = 'nb_appart'
                for feat in vlayer.getFeatures():
                    symbol = QgsSymbol.defaultSymbol(vlayer.geometryType())
                    defaultColorRampNames = QgsStyle().defaultStyle().colorRampNames()
                    mode = QgsGraduatedSymbolRenderer.Jenks
                    colorRamp = QgsStyle().defaultStyle().colorRamp(defaultColorRampNames[5])  #2=vert, 3=violet, 4=jaune-bleu, 5=bleu, 6=vert, 7=gris,                     
                    renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, champs, 4, mode, symbol, colorRamp )                  
                    vlayer.setRenderer(renderer)
                    vlayer.setName(ind+" - "+champs)
                    
            elif ind=='foncier':
                champs = 'nb_terrain'
                for feat in vlayer.getFeatures():
                    symbol = QgsSymbol.defaultSymbol(vlayer.geometryType())
                    defaultColorRampNames = QgsStyle().defaultStyle().colorRampNames()
                    mode = QgsGraduatedSymbolRenderer.Jenks
                    colorRamp = QgsStyle().defaultStyle().colorRamp(defaultColorRampNames[4])  #2=vert, 3=violet, 4=jaune-bleu, 5=bleu, 6=vert, 7=gris,                     
                    renderer = QgsGraduatedSymbolRenderer.createRenderer(vlayer, champs, 4, mode, symbol, colorRamp )                  
                    vlayer.setRenderer(renderer)
                    vlayer.setName(ind+" - "+champs)
            '''        
        val_progression=100
        self.progressBar.setValue(val_progression)
        self.progressBar_2.setValue(val_progression)

        self.progressBar.hide()
        self.progressBar_2.hide()
        self.boutonLanceTraitement2.setEnabled(False)   
    
        #Effacement des tables temporaires
        for indic in ('foncier','appartement','maison','global','evolution'):
            cur.execute("DROP TABLE "+schema+".ind_"+indic+"_"+libDate+" CASCADE;")
            conn.commit()

        QMessageBox.information(self,"Information","Traitement terminé !!!")
        conn.close()

#**************************************************************
#**************FONCTIONS D'IMPORT DE DONNEES******************
#**************************************************************
           
    def ImportCommune(self):
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()
        
        schema=self.lineSchema.text()
        
        if self.recupCheminFichierShp():        
            try:
                cur.execute("SELECT * FROM pg_catalog.pg_tables WHERE schemaname='" + schema + "' AND tablename='commune';")
                res = cur.fetchall()
                if len(res)!=0:
                    reply = QMessageBox.question(self, 'Confirmation','La couche des communes est déjà présente dans la base. Voulez-vous la remplacer ?', QMessageBox.Yes, QMessageBox.No)
                    if reply == QMessageBox.Yes:
                        cur.execute("DROP TABLE "+schema+".commune;")
                        conn.commit()
                        self.progressBar_3.show()
                        val_progression=50
                        self.progressBar_3.setValue(val_progression)
                        layer = QgsVectorLayer(filename, "commune", "ogr")
                        con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=my_id type=MULTIPOLYGON schema="+schema+" table=commune"+" (geom)"
                        err = QgsVectorLayerExporter.exportLayer(layer, con_string, 'postgres', QgsCoordinateReferenceSystem(2154), False)
                        QMessageBox.information(self,"Information","L'import de la couche commune a été réalisé avec succès.")
                        self.progressBar_3.hide()
                    else:
                        pass
                else:
                    self.progressBar_3.show()
                    val_progression=50
                    self.progressBar_3.setValue(val_progression)
                    layer = QgsVectorLayer(filename, "commune", "ogr")
                    con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=my_id type=MULTIPOLYGON schema="+schema+" table=commune"+" (geom)"
                    err = QgsVectorLayerExporter.exportLayer(layer, con_string, 'postgres', QgsCoordinateReferenceSystem(2154), False)
                    QMessageBox.information(self,"Information","L'import de la couche commune a été réalisé avec succès.")
                    self.progressBar_3.hide()
            
            except:
                self.progressBar_3.show()
                val_progression=50
                self.progressBar_3.setValue(val_progression)                
                layer = QgsVectorLayer(filename, "commune", "ogr")
                con_string = "dbname='"+NomBD+"' host='"+AdrServPG+"' port='"+port+"' user='"+user+"' password='"+mdp+"' key=my_id type=MULTIPOLYGON schema="+schema+" table=commune"+" (geom)"
                err = QgsVectorLayerExporter.exportLayer(layer, con_string, 'postgres', QgsCoordinateReferenceSystem(2154), False)
                QMessageBox.information(self,"Information","L'import de la couche commune a été réalisé avec succès.")
                self.progressBar_3.hide()

                conn.close()
        else:
            pass
                        
    def ImportDV3FInit(self):    
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()
        
        schema=self.lineSchema.text()
        
        if self.recupCheminFichierSql():         
            if filename.find('init')==-1:        
                QMessageBox.critical(self,"Information","Le fichier sélectionné n'est pas un fichier d'initialisation de la base DV3F !!!")
            else:
                try:
                    #QMessageBox.information(self,"Information",self.lineCheminFicDV3FInit.text())
                    cur.execute("SELECT * FROM "+schema+".commune limit 1")             
                    try:
                        cur.execute("SELECT * FROM pg_catalog.pg_tables WHERE schemaname='dvf' AND tablename='mutation';")
                        res = cur.fetchall()
                        if len(res)!=0:                        
                            QMessageBox.information(self,"Information","La base de données DV3F a déjà été initialisée !!!")
                        else:
                            self.execFicSql(fichier=filename,param='')                        
                            try:
                                cur.execute("SELECT * FROM pg_catalog.pg_tables WHERE schemaname='dvf' AND tablename='mutation';")
                                res = cur.fetchall()
                                if len(res)!=0:
                                    QMessageBox.information(self,"Information","L'initialisation de la base DV3F a été réalisée avec succès !!!")
                                else:
                                    QMessageBox.warning(self,"Attention","L'initialisation de la base DV3F a échoué !!!")
                                   
                            except:
                                QMessageBox.warning(self,"Attention","L'initialisation de la base DV3F a échoué !!!")
                    except:
                        pass
                        
                except:
                    QMessageBox.critical(self,"Information","Veuillez exécuter la préparation des données pour l'application avant d'importer la donnée DV3F !!!")
                
                conn.close()
        else:
            pass

    def ImportDV3FDept(self):
        # Récupération des paramètres de connexion au serveur PG
        conn = self.ConnectServer()
        cur = conn.cursor()   
        
        if self.recupCheminFichierSql():        
            try:
                dep=os.path.basename(filename).split('_')[1].split('.')[0]
                print(dep)
                #ficAnnexeDvf=self.lineCheminFicDV3FDept.text().replace(filename, "dv3f_initial")            
                try:
                    cur.execute("SELECT * FROM dvf.mutation limit 1")            
                    try:
                        cur.execute("SELECT * FROM dvf_"+dep+".mutation limit 1;")
                        reply = QMessageBox.question(self, 'Confirmation','La base DV3F sur ce département est déjà présente dans la base. Voulez-vous la remplacer ?', QMessageBox.Yes, QMessageBox.No)
                        if reply == QMessageBox.Yes:
                            cur.execute("DROP SCHEMA dvf_"+dep+" CASCADE;")
                            conn.commit()
                            self.execFicSql(fichier=filename,param='')
                            QMessageBox.information(self,"Information","L'import de la base DV3F "+dep+" a été réalisé avec succès.")
                        else:
                            pass
                    except:
                        reply = QMessageBox.question(self, 'Confirmation','Voulez-vous importer la base DV3F sur le département '+dep+' ?', QMessageBox.Yes, QMessageBox.No)
                        if reply == QMessageBox.Yes:
                            #self.execFicSql(fichier=ficAnnexeDvf,param='')
                            self.execFicSql(fichier=filename,param='')
                            QMessageBox.information(self,"Information","L'import de la base DV3F "+dep+" a été réalisé avec succès.")
                        else:
                            pass
                except:
                    QMessageBox.critical(None,"Erreur","La base de données DV3F n'a pas été initialisée !! Veuillez exécuter le fichier dv3f_init avant d'importer les données départementales.")
            except:
                pass                    

            conn.close()
        else:
            pass
            
            
#**************************************************************
#*********************FONCTIONS GENERALES**********************
#**************************************************************
      
    def SelectionDossierSortie(self):
        try:
            dlg_fichier = QFileDialog()
            dlg_fichier.setFileMode(QFileDialog.Directory)
            if dlg_fichier.exec():
                filename = ''.join(dlg_fichier.selectedFiles())
            self.lineDossierSortie.setText(filename)
            
            mDicParamServ = {}
            mSettings = QgsSettings()
            mSettings.beginGroup("QGIS_INOCC")
            mSettings.setValue("dossierSortie", filename)           
            mSettings.endGroup()
        except:
            pass

    def ConnectServer(self):
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
    
        conn = psycopg2.connect("dbname="+NomBD+" user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
        return conn
    
    #lancer une requête
    def execFicSql(self,fichier,param=''):
        # Récupération des paramètres de connexion au serveur PG
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
        schema=self.lineSchema.text()

        str_rep_python = sys.base_prefix  # ajout MM
        str_rep_base = os.path.join(os.path.split(os.path.split(str_rep_python)[0])[0], 'bin')  # ajout MM

        os.environ['PGPASSWORD'] = mdp
        os.environ['PGCLIENTENCODING'] = 'UTF-8'
        psqlPath = os.path.join(str_rep_base, "psql.exe")  # modif MM
        cmd = '"' + psqlPath + '"  -w -h ' + AdrServPG + ' -p ' + port + ' -U ' + user + ' -d ' + NomBD + ' -q -f "' + fichier + '" ' + param 
        print(cmd)

        try:
            os.system(cmd)
        except:
            pass
        
    # creer un repertoire s'il n'existe pas
    def CreerDossier(self,dir):
        try:
            os.mkdir(dir)
        except:
            pass

    # gestion log
    def initLog(self,dossier):
        global table_log,sql_logfile
        try:
            dir_out=dossier+os.sep+"out_"+self.tps()[0:17].replace(":","").replace("-","_")+os.sep
            self.CreerDossier(dir_out)
            table_log=dir_out+os.sep+'log.txt'
            ff=open(table_log,'w')
            ff.close()
            
            sql_logfile=dir_out+os.sep+'logsql.txt'
            ff1=open(sql_logfile,'w')
            ff1.close()
            
        except:
            QMessageBox.critical(self,"Erreur","Veuillez vérifier le chemin d'accès au dossier de sortie (onglet Paramètres serveur PG) !!!")
       
    def ajoutLog(self,text,retour=True):
        global table_log
        try:
            logfile = open(table_log, 'a')
            ret='--'+self.tps()+' > '+text+'\n--\n'
            logfile.write(ret)
            logfile.close()
        except:
            QMessageBox.critical(self,"Erreur","Veuillez vérifier le chemin d'accès au dossier de sortie (onglet Paramètres serveur PG) !!!")
        
    def tps(self):
        return(strftime("%Y%m%d-%H:%M:%S", localtime()))
        print(tps())        
        
    # Fonction de vérification de la base PostgreSQL
    def CheckConnPG(self):
    
        AdrServPG=self.lineAdrServ.text()
        port=self.linePortServ.text()
        user=self.lineUserServ.text()
        mdp=self.lineMdpServ.text()
        NomBD=self.lineBaseDonnees.text()
    
        dossierSortie=self.lineDossierSortie.text()
        schema=self.lineSchema.text()
        
        try:
            # Récupération des paramètres de connexion au serveur PG
            #print(AdrServPG + " " + port + " " + user + " " + mdp + " " + NomBD) 
            conn = psycopg2.connect("dbname=postgres user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
            if NomBD=="":
                QMessageBox.warning(self,"Attention","Le champ base de données n'est pas renseigné !!!")
                pass
            else:
                cur = conn.cursor()
                cur.execute("SELECT version();")
                conn.close()
            
                try:
                    # Récupération des paramètres de connexion au serveur PG
                    conn = psycopg2.connect("dbname="+NomBD+" user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
                    cur = conn.cursor()
                    cur.execute("SELECT * FROM public.spatial_ref_sys limit 1;")
                    
                    try:
                        cur.execute("SELECT schema_name FROM information_schema.schemata WHERE schema_name = '"+schema+"';")
                        res=cur.fetchall()
                        if len(res)==0:
                            QMessageBox.warning(self,"Attention","Le schéma "+schema+" n'existe pas !!!\nVeuillez le créer ou bien demandez à votre administrateur de le faire.")
                        
                        else:
                            QMessageBox.information(self,"Information","Connexion à la base "+NomBD+" réalisée avec succès !!!")
                        conn.close()
                    except:
                        pass                
                    
                    #Mise à jour du fichier de configuration de la base PG (param_serveur.csv)
                    mDicParam = {}
                    mSettings = QgsSettings()
                    mSettings.beginGroup("QGIS_INOCC")
                    mDicParam["AdrServPG"] = self.lineAdrServ.text()
                    mDicParam["port"] = self.linePortServ.text()                    
                    mDicParam["user"] = self.lineUserServ.text()
                    mDicParam["mdp"] = self.lineMdpServ.text()
                    mDicParam["NomBD"] = self.lineBaseDonnees.text()
                    mDicParam["schema"] = self.lineSchema.text()
                    mDicParam["dossierSortie"] = self.lineDossierSortie.text()
                    for key, value in mDicParam.items():
                       mSettings.setValue(key, value)
                    mSettings.endGroup()
            
                    
                except:
                    if schema=="":
                        QMessageBox.information(self,"Information","Le champ du schéma est vide. Si possible, il est conseillé d'utiliser le schéma public.")
                        pass
                    else:
                        reply = QMessageBox.question(self, 'Confirmation','La base de données n\'existe pas. Voulez-vous la créer ?', QMessageBox.Yes, QMessageBox.No)

                        if reply == QMessageBox.Yes:
                            try:
                                conn = psycopg2.connect("dbname=postgres user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
                                conn.autocommit = True
                                cur = conn.cursor()
                                cur.execute("CREATE DATABASE "+NomBD)
                                conn.close()
                                conn2 = psycopg2.connect("dbname="+NomBD+" user=" + user + " password="+mdp+" host="+AdrServPG+" port ="+port+ " connect_timeout=1 ")
                                conn2.autocommit = True
                                cur2 = conn2.cursor()
                                cur2.execute("CREATE EXTENSION postgis;")
                                conn2.commit()                                

                                try: #création du schéma si besoin
                                    cur2.execute("CREATE SCHEMA "+schema+" AUTHORIZATION postgres;")
                                    conn2.commit()
                                except:
                                    pass
                                conn2.close()
                                QMessageBox.information(self,"Information","Création de la base "+NomBD+" effectuée avec succès !!!")
                                
                                #Mise à jour du fichier de configuration de la base PG (QGIS.ini)
                                mDicParam = {}
                                mSettings = QgsSettings()
                                mSettings.beginGroup("QGIS_INOCC")
                                mDicParam["AdrServPG"] = self.lineAdrServ.text()
                                mDicParam["port"] = self.linePortServ.text()                                
                                mDicParam["user"] = self.lineUserServ.text()
                                mDicParam["mdp"] = self.lineMdpServ.text()
                                mDicParam["NomBD"] = self.lineBaseDonnees.text()
                                mDicParam["schema"] = self.lineSchema.text()
                                mDicParam["dossierSortie"] = self.lineDossierSortie.text()
                                for key, value in mDicParam.items():
                                   mSettings.setValue(key, value)
                                mSettings.endGroup()                    
                            except:
                                QMessageBox.critical(self,"Attention","Le nom de la base de données ne doit pas comporter de caractères spéciaux et ne doit pas démarrer par un chiffre !!! ")
        except:
            QMessageBox.critical(self,"Information","Les paramètres de connexion au serveur Postgresql sont incorrects !!! ")
        
    def NettoyerBase(self):
        # Récupération des paramètres de connexion au serveur PG        
        reply = QMessageBox.question(self, 'Confirmation','Cette action supprimera les fichiers log. Voulez-vous continuer ?', QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes: 
            #vidage du dossier log
            try:
                shutil.rmtree(os.path.dirname(__file__)+'/log')
            except:
                pass
            
            QMessageBox.information(self,"Information","Le dossier log a été effacé !!!")
        else:
            pass
                    
    def recupCheminFichierShp(self):
        global filename
        dlg_fichier = QFileDialog()
        dlg_fichier.setFileMode(QFileDialog.AnyFile)
        dlg_fichier.setNameFilter("shapefile (*.shp)")
        if dlg_fichier.exec():
            try:
                filename = ''.join(dlg_fichier.selectedFiles())
                return filename
            except:
                pass

    def recupCheminFichierSql(self):
        global filename
        dlg_fichier = QFileDialog()
        dlg_fichier.setFileMode(QFileDialog.AnyFile)
        dlg_fichier.setNameFilter("sqlfile (*.sql)")
        if dlg_fichier.exec():
            try:
                filename = ''.join(dlg_fichier.selectedFiles())
                return filename
            except:
                pass

    # Fonction afficher la notice DV3F
    def AfficheNoticeDV3F(self):
        os.system(os.path.dirname(__file__)+"/data/notice_inocc_v2.pdf")
        
    # Fonction afficher boîte de dialogue initiale
    def AfficheBoiteDialogue(self):
        #Récupération des variables du QGIS3.INI
        mDic_LH = self.returnDialogParam()
        self.mDic_LH = mDic_LH
        self.openParam = True if self.mDic_LH["openParam"] == "true" else False
        d = doConfirme.Dialog(self.openParam)
        d.exec_()

    def returnDialogParam(self):
        mDicAutre = {}
        mSettings = QgsSettings()
        mSettings.beginGroup("QGIS_INOCC")
        #mSettings.beginGroup("Generale")
        #Ajouter si autre param
        valueDefautOpenParam = "true"
        mDicAutre["openParam"] = valueDefautOpenParam
        for key, value in mDicAutre.items():
            if not mSettings.contains(key) :
               mSettings.setValue(key, value)
            else :
               mDicAutre[key] = mSettings.value(key)
        mSettings.endGroup()
        return mDicAutre            
        
    def returnParamServPG(self):
        mDicParamServ = {}
        mSettings = QgsSettings()
        mSettings.beginGroup("QGIS_INOCC")
        
        mDicParamServ["AdrServPG"] = mSettings.value("AdrServPG")
        mDicParamServ["port"] = mSettings.value("port")
        mDicParamServ["user"] = mSettings.value("user")
        mDicParamServ["mdp"] = mSettings.value("mdp")
        mDicParamServ["NomBD"] = mSettings.value("NomBD")        
        mDicParamServ["schema"] = mSettings.value("schema")
        mDicParamServ["dossierSortie"] = mSettings.value("dossierSortie")
        
        #mDicParamServ[key] = mSettings.value(key)
        mSettings.endGroup()
        return mDicParamServ
        